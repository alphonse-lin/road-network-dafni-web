import pandas as pd
import os
from pathlib import Path
import logging
from datetime import datetime
from typing import Optional, Tuple, List
import numpy as np
import sys

def setup_logger(output_dir: str) -> logging.Logger:
    """设置日志记录器"""
    log_dir = Path(output_dir) / 'logs'
    log_dir.mkdir(parents=True, exist_ok=True)
    
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    log_file = log_dir / f'vulnerability_calculation_{timestamp}.log'
    
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(log_file, encoding='utf-8'),
            logging.StreamHandler()
        ]
    )
    
    return logging.getLogger(__name__)

def calculate_vulnerability_index(row: pd.Series, time_interval: int) -> pd.Series:
    """
    计算每一行的脆弱性指数和风险等级
    
    Parameters:
    -----------
    row : pd.Series
        输入数据行
    time_interval : int
        时间间隔（秒）
    
    Returns:
    --------
    pd.Series
        包含风险等级和脆弱性指数的Series
    """
    results = []
    steps = int(7200 / time_interval)  # 计算时间步数
    
    for i in range(3, 3 + steps):
        # 计算交通流变化率
        traffic_diff = 0 if row[i-1] == 0 else (row[i] - row[i-1])
        
        # 计算空间句法指标变化率
        choice_diff = 0 if row[i+steps] == 0 else (row[i+steps+1] - row[i+steps])
        
        # 确定风险等级
        if row[i+steps+1] == 0:
            risk_level = 'flooded'
        elif traffic_diff <= 0 and choice_diff <= 0:
            traffic_diff = 0.0001  # 避免零值
            risk_level = 'lowest'
        elif traffic_diff <= 0 and choice_diff > 0:
            traffic_diff = 0.0001
            risk_level = 'low_risk'
        elif traffic_diff > 0 and choice_diff < 0:
            risk_level = 'high_risk'
        elif traffic_diff > 0 and choice_diff > 0:
            risk_level = 'highest_risk'
        else:
            risk_level = 'unknown'
        
        # 计算脆弱性指数
        vulnerability = abs(choice_diff) * traffic_diff
        results.append((risk_level, vulnerability))
    
    # 构建结果索引
    index_risk = [f'risk_level_{i}' for i in range(steps)]
    index_vuln = [f'vulnerability_{i}' for i in range(steps)]
    combined_index = [val for pair in zip(index_risk, index_vuln) for val in pair]
    
    return pd.Series([item for pair in results for item in pair], index=combined_index)

def resample_time_series(df: pd.DataFrame, 
                        original_interval: int, 
                        new_interval: int) -> pd.DataFrame:
    """
    重采样时间序列数据
    
    Parameters:
    -----------
    df : pd.DataFrame
        输入数据框
    original_interval : int
        原始时间间隔（秒）
    new_interval : int
        新的时间间隔（秒）
        
    Returns:
    --------
    pd.DataFrame
        重采样后的数据框
    """
    columns_to_combine = new_interval // original_interval
    
    # 合并交通流数据
    new_counts = [df.iloc[:, 3 + i*columns_to_combine : 3 + (i+1)*columns_to_combine].sum(axis=1) 
                 for i in range((19-3)//columns_to_combine)]
    
    # 选择空间句法数据
    selected_cols = [20 + i*columns_to_combine - 1 
                    for i in range((36-20)//columns_to_combine + 1)]
    selected_data = df.iloc[:, selected_cols]
    
    # 创建新数据框
    new_df = pd.DataFrame(new_counts).transpose()
    new_df.columns = [f'{int(df.columns[2])+(i+1)*new_interval}' 
                     for i in range(new_df.shape[1])]
    
    return pd.concat([df.iloc[:,:3], new_df, selected_data.reset_index(drop=True)], axis=1)

def calculate_vulnerability(input_file: str, 
                          output_dir: str,
                          time_interval: int = 450,
                          output_filename: Optional[str] = None) -> bool:
    """
    计算道路网络脆弱性指数
    
    Parameters:
    -----------
    input_file : str
        输入文件路径（DTW匹配结果）
    output_dir : str
        输出目录路径
    time_interval : int, optional
        时间间隔（秒），默认450秒
    output_filename : str, optional
        输出文件名，如果不指定则自动生成
        
    Returns:
    --------
    bool
        计算是否成功
    """
    try:
        logger = setup_logger(output_dir)
        logger.info("开始计算脆弱性指数")
        
        # 创建输出目录
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # 读取输入数据
        logger.info(f"读取输入文件: {input_file}")
        input_df = pd.read_csv(input_file)
        
        # 重采样数据
        logger.info(f"重采样数据到{time_interval}秒间隔")
        resampled_df = resample_time_series(input_df, time_interval, time_interval)
        
        # 计算脆弱性指数
        logger.info("计算脆弱性指数")
        vulnerability_data = resampled_df.apply(
            calculate_vulnerability_index, 
            time_interval=time_interval, 
            axis=1
        )
        
        # 合并结果
        output_df = pd.concat([resampled_df, vulnerability_data], axis=1)
        
        # 生成输出文件名
        if output_filename is None:
            output_filename = f"vulnerability_index_{time_interval}s_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
        
        # 保存结果
        output_path = output_dir / output_filename
        output_df.to_csv(output_path, index=False)
        logger.info(f"计算完成，结果已保存到: {output_path}")
        
        return True
        
    except Exception as e:
        logger.exception(f"计算过程中发生错误: {str(e)}")
        return False

if __name__ == '__main__':
    # 命令行参数处理
    if len(sys.argv) < 3:
        print("Usage: python vulnerabilityCalculation.py <input_file> <output_dir> [time_interval] [output_filename]")
        print("Example: python vulnerabilityCalculation.py dtw_matching.csv ./output 450")
        sys.exit(1)
        
    input_file = sys.argv[1]
    output_dir = sys.argv[2]
    time_interval = int(sys.argv[3]) if len(sys.argv) > 3 else 450
    output_filename = sys.argv[4] if len(sys.argv) > 4 else None
    
    # 执行计算
    success = calculate_vulnerability(input_file, output_dir, time_interval, output_filename)
    
    sys.exit(0 if success else 1)

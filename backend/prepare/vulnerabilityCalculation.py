import pandas as pd
import os
from pathlib import Path
import logging
from datetime import datetime
from typing import Optional, Tuple, List
import numpy as np
import sys

def setup_logger(output_dir: str) -> logging.Logger:
    """设置日志记录器"""
    log_dir = Path(output_dir) / 'logs'
    log_dir.mkdir(parents=True, exist_ok=True)
    
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    log_file = log_dir / f'vulnerability_calculation_{timestamp}.log'
    
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(log_file, encoding='utf-8'),
            logging.StreamHandler()
        ]
    )
    
    return logging.getLogger(__name__)

def calculate_vulnerability_index(row: pd.Series, time_interval: int) -> pd.Series:
    """
    计算每一行的脆弱性指数和风险等级
    
    Parameters:
    -----------
    row : pd.Series
        输入数据行，包含数字列（交通流数据）和MC_前缀的空间句法数据
    time_interval : int
        时间间隔（秒）
    
    Returns:
    --------
    pd.Series
        包含风险等级和脆弱性指数的Series
    """
    # 找到交通流数据列（纯数字）和空间句法数据列（MC_开头）
    traffic_cols = [col for col in row.index if col.replace('.', '').isdigit()]
    spatial_cols = [col for col in row.index if col.startswith('MC_')]
    
    results = []
    
    # 计算差分
    for i in range(len(traffic_cols)-1):
        # 计算交通流变化率
        traffic_flow1 = row[traffic_cols[i]]
        traffic_flow2 = row[traffic_cols[i+1]]
        traffic_diff = 0 if traffic_flow1 == 0 else (traffic_flow2 - traffic_flow1)
        
        # 计算空间句法指标变化率
        spatial_value1 = row[spatial_cols[i]]
        spatial_value2 = row[spatial_cols[i+1]]
        spatial_diff = 0 if spatial_value1 == 0 else (spatial_value2 - spatial_value1)
        
        # 确定风险等级
        if traffic_flow2 == 0:
            risk_level = 'flooded'
        elif traffic_diff <= 0 and spatial_diff <= 0:
            risk_level = 'lowest'
        elif traffic_diff <= 0 and spatial_diff > 0:
            risk_level = 'low_risk'
        elif traffic_diff > 0 and spatial_diff < 0:
            risk_level = 'high_risk'
        elif traffic_diff > 0 and spatial_diff > 0:
            risk_level = 'highest_risk'
        else:
            risk_level = 'unknown'
        
        # 计算脆弱性指数
        vulnerability = abs(spatial_diff) * abs(traffic_diff) if traffic_diff != 0 else 0
        results.append((risk_level, vulnerability))
    
    # 构建结果索引
    index_risk = [f'risk_level_{i*time_interval}' for i in range(len(results))]
    index_vuln = [f'vulnerability_{i*time_interval}' for i in range(len(results))]
    combined_index = [val for pair in zip(index_risk, index_vuln) for val in pair]
    
    return pd.Series([item for pair in results for item in pair], index=combined_index)

def resample_time_series(df: pd.DataFrame, 
                        original_interval: int, 
                        new_interval: int) -> pd.DataFrame:
    """
    重采样时间序列数据
    
    Parameters:
    -----------
    df : pd.DataFrame
        输入数据框
    original_interval : int
        原始时间间隔（秒）
    new_interval : int
        新的时间间隔（秒）
        
    Returns:
    --------
    pd.DataFrame
        重采样后的数据框
    """
    if new_interval % original_interval != 0:
        raise ValueError(f"新时间间隔 {new_interval} 必须是原始时间间隔 {original_interval} 的整数倍")
    
    # 获取基础列
    base_cols = ['CurveId', 'link_id']
    base_data = df[base_cols].copy()
    
    # 分离交通流列和空间句法列
    traffic_cols = [col for col in df.columns if col.replace('.', '').isdigit()]
    spatial_cols = [col for col in df.columns if col.startswith('MC_')]
    
    # 计算需要合并的列数
    step = new_interval // original_interval
    
    # 重采样交通流数据
    new_traffic_data = []
    for i in range(0, len(traffic_cols), step):
        if i + step <= len(traffic_cols):
            # 使用平均值
            new_traffic_data.append(df[traffic_cols[i:i+step]].mean(axis=1))
    
    # 重采样空间句法数据
    new_spatial_data = []
    for i in range(0, len(spatial_cols), step):
        if i + step <= len(spatial_cols):
            # 使用最后一个值
            new_spatial_data.append(df[spatial_cols[i+step-1]])
    
    # 构建新的列名
    new_traffic_cols = [str(25200 + i*new_interval) for i in range(len(new_traffic_data))]
    new_spatial_cols = [f'MC_1000_{i*new_interval}' for i in range(len(new_spatial_data))]
    
    # 合并所有数据
    result_df = base_data.copy()
    for col, data in zip(new_traffic_cols, new_traffic_data):
        result_df[col] = data
    for col, data in zip(new_spatial_cols, new_spatial_data):
        result_df[col] = data
    
    return result_df

def calculate_vulnerability(input_file: str, 
                          output_dir: str,
                          time_interval: int = 450,
                          output_filename: Optional[str] = None) -> bool:
    """
    计算道路网络脆弱性指数
    
    Parameters:
    -----------
    input_file : str
        输入文件路径（DTW匹配结果）
    output_dir : str
        输出目录路径
    time_interval : int, optional
        时间间隔（秒），默认450秒
    output_filename : str, optional
        输出文件名，如果不指定则自动生成
        
    Returns:
    --------
    bool
        计算是否成功
    """
    try:
        logger = setup_logger(output_dir)
        logger.info("开始计算脆弱性指数")
        
        # 创建输出目录
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # 读取输入数据
        logger.info(f"读取输入文件: {input_file}")
        input_df = pd.read_csv(input_file)
        
        # 重采样数据
        logger.info(f"重采样数据到{time_interval}秒间隔")
        resampled_df = resample_time_series(input_df, time_interval, time_interval)
        
        # 计算脆弱性指数
        logger.info("计算脆弱性指数")
        vulnerability_data = resampled_df.apply(
            calculate_vulnerability_index, 
            time_interval=time_interval, 
            axis=1
        )
        
        # 只保留基础标识列和计算结果
        base_cols = ['CurveId', 'link_id']
        output_df = pd.concat([resampled_df[base_cols], vulnerability_data], axis=1)
        
        # 生成输出文件名
        if output_filename is None:
            output_filename = f"vulnerability_index_{time_interval}s_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
        
        # 保存结果
        output_path = output_dir / output_filename
        output_df.to_csv(output_path, index=False)
        logger.info(f"计算完成，结果已保存到: {output_path}")
        
        return True
        
    except Exception as e:
        logger.exception(f"计算过程中发生错误: {str(e)}")
        return False

if __name__ == '__main__':
    # # 命令行参数处理
    # if len(sys.argv) < 3:
    #     print("Usage: python vulnerabilityCalculation.py <input_file> <output_dir> [time_interval] [output_filename]")
    #     print("Example: python vulnerabilityCalculation.py dtw_matching.csv ./output 450")
    #     sys.exit(1)
        
    input_file = r'src\assets\sample_data\output\004_merged_data\merged_output.csv'
    output_dir = r'src\assets\sample_data\output\004_merged_data'
    time_interval = 450
    output_filename = 'road_vulnerability_index.csv'
    
    # 执行计算
    success = calculate_vulnerability(input_file, output_dir, time_interval, output_filename)
    
    sys.exit(0 if success else 1)

<template>
  <div ref="mapContainer" class="vulnerability-polar-map"></div>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue'
import * as echarts from 'echarts'

const props = defineProps({
  vulnerabilityData: {
    type: Array,
    required: true
  }
})

const mapContainer = ref(null)
let chart = null

// 定义角度偏移量（箭头长度）
const angleOffset = Math.PI / 30 // 可以调整这个值来改变箭头长度

// 计算极坐标角度
const calculateAngle = (item) => {
  const linkId = parseInt(item.link_id)
  return (linkId % 360) * (Math.PI / 180)
}

// 计算极坐标半径
const calculateRadius = (vulnerability) => {
  const value = parseFloat(vulnerability)
  if (isNaN(value)) return 0
  
  const minRadius = 20
  const maxRadius = 100
  return minRadius + (value * (maxRadius - minRadius))
}

const initChart = () => {
  const option = {
    polar: {
      center: ['50%', '50%']
    },
    angleAxis: {
      type: 'value',
      startAngle: 0,
      show: false
    },
    radiusAxis: {
      type: 'value',
      show: false
    },
    series: [{
      type: 'custom',
      coordinateSystem: 'polar',
      renderItem: (params, api) => {
        const start = api.coord([
          api.value(0),
          api.value(1)
        ])
        const end = api.coord([
          api.value(2),
          api.value(3)
        ])
        
        const timeRatio = api.value(4)
        const color = getColorByTime(timeRatio)

        // 计算箭头
        const dx = end[0] - start[0]
        const dy = end[1] - start[1]
        const angle = Math.atan2(dy, dx)
        
        // 箭头大小
        const arrowLength = 10
        const arrowAngle = Math.PI / 6 // 30度

        // 计算箭头两个点的位置
        const arrowLeft = [
          end[0] - arrowLength * Math.cos(angle + arrowAngle),
          end[1] - arrowLength * Math.sin(angle + arrowAngle)
        ]
        const arrowRight = [
          end[0] - arrowLength * Math.cos(angle - arrowAngle),
          end[1] - arrowLength * Math.sin(angle - arrowAngle)
        ]

        return {
          type: 'path',
          shape: {
            pathData: [
              ['M', start[0], start[1]],
              ['L', end[0], end[1]],
              ['M', end[0], end[1]],
              ['L', arrowLeft[0], arrowLeft[1]],
              ['M', end[0], end[1]],
              ['L', arrowRight[0], arrowRight[1]]
            ].map(item => item.join(' ')).join(' ')
          },
          style: {
            stroke: color,
            lineWidth: 2,
            fill: 'none'
          }
        }
      },
      data: transformData(props.vulnerabilityData)
    }]
  }

  chart = echarts.init(mapContainer.value)
  chart.setOption(option)
}

// 将数据转换为极坐标系所需格式
const transformData = (data) => {
  if (!data) return []
  
  return data.map(item => {
    const vul0 = parseFloat(item.vulnerability_0)
    const vul450 = parseFloat(item.vulnerability_450)
    
    // 计算时间进度（0到1之间）
    const timeProgress = 1 // 这里可以根据需要调整

    return [
      calculateAngle(item),
      calculateRadius(vul0),
      calculateAngle(item) + angleOffset,
      calculateRadius(vul450),
      timeProgress
    ]
  })
}

// 根据时间进度获取颜色
const getColorByTime = (ratio) => {
  const colors = [
    [255, 0, 0],    // 红色
    [255, 165, 0],  // 橙色
    [255, 255, 0],  // 黄色
    [0, 0, 255]     // 蓝色
  ]
  
  // 计算渐变色
  const index = ratio * (colors.length - 1)
  const lower = Math.floor(index)
  const upper = Math.ceil(index)
  const t = index - lower
  
  const color = colors[lower].map((start, i) => {
    const end = colors[upper][i]
    return Math.round(start + (end - start) * t)
  })
  
  return `rgb(${color.join(',')})`
}

onMounted(() => {
  initChart()
  window.addEventListener('resize', () => {
    chart?.resize()
  })
})

onUnmounted(() => {
  chart?.dispose()
})
</script>

<style scoped>
.vulnerability-polar-map {
  width: 100%;
  height: 100%;
  min-height: 600px;
}
</style> 